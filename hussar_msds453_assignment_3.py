# -*- coding: utf-8 -*-
"""Hussar_MSDS453_Assignment_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17jrc6QXU1xj2VZ3J48Q5qCvE3KX18Ob5
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
import json
import os
from typing import Dict, List, Tuple, Optional
import logging

warnings.filterwarnings('ignore')

class MultiLevelTradingSystem:
    def __init__(self, symbol: str = "BNED", initial_capital: float = 100000):
        self.symbol = symbol
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.positions = 0
        self.trades = []
        self.data = None

        # risk tolerance levels
        self.risk_levels = {
            'conservative': {'momentum_threshold': 0.02, 'mean_reversion_threshold': 0.015, 'position_size': 0.1},
            'moderate': {'momentum_threshold': 0.015, 'mean_reversion_threshold': 0.02, 'position_size': 0.2},
            'aggressive': {'momentum_threshold': 0.01, 'mean_reversion_threshold': 0.025, 'position_size': 0.3}
        }

        self.short_window = 10
        self.long_window = 30
        self.rsi_window = 14
        self.bollinger_window = 20
        self.bollinger_std = 2

        # Setup logging
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)

    def fetch_data(self, period: str = "2y") -> pd.DataFrame:
        try:
            ticker = yf.Ticker(self.symbol)
            self.data = ticker.history(period=period)
            self.logger.info(f"Fetched {len(self.data)} days of data for {self.symbol}")
            return self.data
        except Exception as e:
            self.logger.error(f"Error fetching data: {e}")
            return None

    def calculate_technical_indicators(self) -> pd.DataFrame:
        if self.data is None:
            raise ValueError("No data available. Call fetch_data() first.")

        df = self.data.copy()

        # moving averages
        df['SMA_short'] = df['Close'].rolling(window=self.short_window).mean()
        df['SMA_long'] = df['Close'].rolling(window=self.long_window).mean()
        df['EMA_short'] = df['Close'].ewm(span=self.short_window).mean()
        df['EMA_long'] = df['Close'].ewm(span=self.long_window).mean()

        # RSI calculation
        delta = df['Close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=self.rsi_window).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=self.rsi_window).mean()
        rs = gain / loss
        df['RSI'] = 100 - (100 / (1 + rs))

        # bollinger bands
        df['BB_middle'] = df['Close'].rolling(window=self.bollinger_window).mean()
        bb_std = df['Close'].rolling(window=self.bollinger_window).std()
        df['BB_upper'] = df['BB_middle'] + (bb_std * self.bollinger_std)
        df['BB_lower'] = df['BB_middle'] - (bb_std * self.bollinger_std)
        df['BB_width'] = df['BB_upper'] - df['BB_lower']
        df['BB_position'] = (df['Close'] - df['BB_lower']) / df['BB_width']

        # momentum indicators
        df['Price_Change'] = df['Close'].pct_change()
        df['Momentum'] = df['Close'] / df['Close'].shift(10) - 1
        df['Volatility'] = df['Price_Change'].rolling(window=20).std()

        # volume indicators
        df['Volume_SMA'] = df['Volume'].rolling(window=20).mean()
        df['Volume_Ratio'] = df['Volume'] / df['Volume_SMA']

        self.data = df
        return df

    def generate_momentum_signals(self, risk_level: str) -> pd.Series:
        """Generate momentum-based trading signals"""
        threshold = self.risk_levels[risk_level]['momentum_threshold']

        # momentum strategy
        momentum_condition = (
            (self.data['EMA_short'] > self.data['EMA_long']) &
            (self.data['Momentum'] > threshold) &
            (self.data['RSI'] < 70) &  # not overbought
            (self.data['Volume_Ratio'] > 1.2)  # above average volume
        )

        # sell when short MA < long MA or momentum is negative
        momentum_sell = (
            (self.data['EMA_short'] < self.data['EMA_long']) |
            (self.data['Momentum'] < -threshold) |
            (self.data['RSI'] > 80)  # Overbought
        )

        signals = pd.Series(0, index=self.data.index)
        signals[momentum_condition] = 1
        signals[momentum_sell] = -1

        return signals

    def generate_mean_reversion_signals(self, risk_level: str) -> pd.Series:
        """generate mean-reversion trading signals"""
        threshold = self.risk_levels[risk_level]['mean_reversion_threshold']

        # mean reversion
        mean_reversion_buy = (
            (self.data['BB_position'] < 0.1) &  # Near lower band
            (self.data['RSI'] < 30) &  # Oversold
            (abs(self.data['Price_Change']) > threshold)  # Significant move
        )

        # sell when price is above upper Bollinger Band
        mean_reversion_sell = (
            (self.data['BB_position'] > 0.9) |  # Near upper band
            (self.data['RSI'] > 70)  # Overbought
        )

        signals = pd.Series(0, index=self.data.index)
        signals[mean_reversion_buy] = 1
        signals[mean_reversion_sell] = -1

        return signals

    def combine_signals(self, momentum_signals: pd.Series, mean_reversion_signals: pd.Series,
                       risk_level: str) -> pd.Series:
        """momentum and mean-reversion signals with risk management"""

        volatility_threshold = self.data['Volatility'].rolling(window=50).quantile(0.7)
        high_volatility = self.data['Volatility'] > volatility_threshold
        combined_signals = pd.Series(0, index=self.data.index)

        # high volatility periods - mean reversion
        high_vol_mask = high_volatility.fillna(False)
        combined_signals[high_vol_mask] = mean_reversion_signals[high_vol_mask] * 0.7 + \
                                         momentum_signals[high_vol_mask] * 0.3

        # low volatility periods - momentum
        low_vol_mask = ~high_vol_mask
        combined_signals[low_vol_mask] = momentum_signals[low_vol_mask] * 0.7 + \
                                        mean_reversion_signals[low_vol_mask] * 0.3

        # threshold to generate discrete signals
        buy_threshold = 0.5
        sell_threshold = -0.5

        final_signals = pd.Series(0, index=self.data.index)
        final_signals[combined_signals > buy_threshold] = 1
        final_signals[combined_signals < sell_threshold] = -1

        return final_signals

    def execute_trades(self, signals: pd.Series, risk_level: str) -> List[Dict]:
        """execute trades based on signals with position sizing"""
        position_size_ratio = self.risk_levels[risk_level]['position_size']
        trades = []
        current_position = 0

        for date, signal in signals.items():
            if pd.isna(signal) or signal == 0:
                continue

            price = self.data.loc[date, 'Close']

            if signal == 1 and current_position <= 0:  # buy signal
                position_size = int((self.current_capital * position_size_ratio) / price)
                if position_size > 0:
                    trade_value = position_size * price
                    self.current_capital -= trade_value
                    current_position += position_size

                    trade = {
                        'date': date,
                        'action': 'BUY',
                        'price': price,
                        'quantity': position_size,
                        'value': trade_value,
                        'capital_remaining': self.current_capital,
                        'position': current_position
                    }
                    trades.append(trade)
                    self.logger.info(f"BUY: {position_size} shares at ${price:.2f} on {date}")

            elif signal == -1 and current_position > 0:  # sell signal
                trade_value = current_position * price
                self.current_capital += trade_value

                trade = {
                    'date': date,
                    'action': 'SELL',
                    'price': price,
                    'quantity': current_position,
                    'value': trade_value,
                    'capital_remaining': self.current_capital,
                    'position': 0
                }
                trades.append(trade)
                self.logger.info(f"SELL: {current_position} shares at ${price:.2f} on {date}")
                current_position = 0

        # close any remaining position at the end
        if current_position > 0:
            final_date = self.data.index[-1]
            final_price = self.data.loc[final_date, 'Close']
            trade_value = current_position * final_price
            self.current_capital += trade_value

            trade = {
                'date': final_date,
                'action': 'SELL',
                'price': final_price,
                'quantity': current_position,
                'value': trade_value,
                'capital_remaining': self.current_capital,
                'position': 0
            }
            trades.append(trade)

        self.positions = current_position
        self.trades = trades
        return trades

    def calculate_performance_metrics(self) -> Dict:
        """calculate trading performance metrics"""
        if not self.trades:
            return {}

        trades_df = pd.DataFrame(self.trades)
        buy_trades = trades_df[trades_df['action'] == 'BUY']
        sell_trades = trades_df[trades_df['action'] == 'SELL']

        # returns
        total_return = (self.current_capital - self.initial_capital) / self.initial_capital

        # buy and hold return for comparison
        start_price = self.data['Close'].iloc[0]
        end_price = self.data['Close'].iloc[-1]
        buy_hold_return = (end_price - start_price) / start_price

        # trade-level returns
        trade_returns = []
        for i in range(min(len(buy_trades), len(sell_trades))):
            buy_price = buy_trades.iloc[i]['price']
            sell_price = sell_trades.iloc[i]['price']
            trade_return = (sell_price - buy_price) / buy_price
            trade_returns.append(trade_return)

        if trade_returns:
            win_rate = sum(1 for r in trade_returns if r > 0) / len(trade_returns)
            avg_return_per_trade = np.mean(trade_returns)
            sharpe_ratio = np.mean(trade_returns) / np.std(trade_returns) if np.std(trade_returns) > 0 else 0
        else:
            win_rate = 0
            avg_return_per_trade = 0
            sharpe_ratio = 0

        metrics = {
            'total_return': total_return,
            'buy_hold_return': buy_hold_return,
            'excess_return': total_return - buy_hold_return,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'avg_return_per_trade': avg_return_per_trade,
            'sharpe_ratio': sharpe_ratio,
            'final_capital': self.current_capital
        }

        return metrics

    def plot_results(self, signals: pd.Series, risk_level: str):
        fig, axes = plt.subplots(3, 1, figsize=(15, 12))

        # chart with signals
        axes[0].plot(self.data.index, self.data['Close'], label='Close Price', alpha=0.7)
        axes[0].plot(self.data.index, self.data['SMA_short'], label=f'SMA {self.short_window}', alpha=0.6)
        axes[0].plot(self.data.index, self.data['SMA_long'], label=f'SMA {self.long_window}', alpha=0.6)

        # buy/sell points
        buy_signals = self.data.index[signals == 1]
        sell_signals = self.data.index[signals == -1]

        if len(buy_signals) > 0:
            axes[0].scatter(buy_signals, self.data.loc[buy_signals, 'Close'],
                          color='green', marker='^', s=100, label='Buy Signal')
        if len(sell_signals) > 0:
            axes[0].scatter(sell_signals, self.data.loc[sell_signals, 'Close'],
                          color='red', marker='v', s=100, label='Sell Signal')

        axes[0].set_title(f'{self.symbol} - Trading Signals ({risk_level.title()} Risk)')
        axes[0].set_ylabel('Price ($)')
        axes[0].legend()
        axes[0].grid(True, alpha=0.3)

        # RSI
        axes[1].plot(self.data.index, self.data['RSI'], label='RSI', color='purple')
        axes[1].axhline(y=70, color='r', linestyle='--', alpha=0.5, label='Overbought')
        axes[1].axhline(y=30, color='g', linestyle='--', alpha=0.5, label='Oversold')
        axes[1].set_title('RSI Indicator')
        axes[1].set_ylabel('RSI')
        axes[1].legend()
        axes[1].grid(True, alpha=0.3)

        # Bollinger Bands
        axes[2].plot(self.data.index, self.data['Close'], label='Close Price')
        axes[2].plot(self.data.index, self.data['BB_upper'], label='Upper Band', alpha=0.5)
        axes[2].plot(self.data.index, self.data['BB_lower'], label='Lower Band', alpha=0.5)
        axes[2].fill_between(self.data.index, self.data['BB_upper'], self.data['BB_lower'], alpha=0.1)
        axes[2].set_title('Bollinger Bands')
        axes[2].set_ylabel('Price ($)')
        axes[2].set_xlabel('Date')
        axes[2].legend()
        axes[2].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.savefig(f'bned_trading_analysis_{risk_level}.png', dpi=300, bbox_inches='tight')
        plt.show()

    def run_backtest(self, risk_level: str = 'moderate') -> Dict:
        self.logger.info(f"Starting backtest for {self.symbol} with {risk_level} risk tolerance")

        # capital and positions
        self.current_capital = self.initial_capital
        self.positions = 0
        self.trades = []

        # prepare data
        if self.data is None:
            self.fetch_data()

        self.calculate_technical_indicators()

        # signals
        momentum_signals = self.generate_momentum_signals(risk_level)
        mean_reversion_signals = self.generate_mean_reversion_signals(risk_level)
        combined_signals = self.combine_signals(momentum_signals, mean_reversion_signals, risk_level)

        # execute trades
        trades = self.execute_trades(combined_signals, risk_level)

        # calculate performance
        performance = self.calculate_performance_metrics()

        # plot
        self.plot_results(combined_signals, risk_level)

        return performance

def compare_risk_levels(symbol: str = "BNED") -> pd.DataFrame:
    results = []

    for risk_level in ['conservative', 'moderate', 'aggressive']:
        print(f"Running backtest for {risk_level.upper()} risk tolerance")

        # Save the dataset (using the last system created in compare_risk_levels)
        system = MultiLevelTradingSystem("BNED")
        system.fetch_data()
        system.calculate_technical_indicators()
        save_dataset(system)
        performance = system.run_backtest(risk_level)

        performance['risk_level'] = risk_level
        results.append(performance)

        # summary
        print(f"\nPerformance Summary - {risk_level.title()} Risk:")
        print(f"Total Return: {performance['total_return']:.2%}")
        print(f"Buy & Hold Return: {performance['buy_hold_return']:.2%}")
        print(f"Excess Return: {performance['excess_return']:.2%}")
        print(f"Total Trades: {performance['total_trades']}")
        print(f"Win Rate: {performance['win_rate']:.2%}")
        print(f"Sharpe Ratio: {performance['sharpe_ratio']:.3f}")
        print(f"Final Capital: ${performance['final_capital']:,.2f}")

    # comparison DataFrame
    comparison_df = pd.DataFrame(results)
    return comparison_df

def save_results(results_df: pd.DataFrame, filename: str = 'trade.csv'):
    """Save results to CSV file"""
    results_df.to_csv(filename, index=False)

def save_dataset(system: MultiLevelTradingSystem, filename: str = 'bned_dataset.csv'):
    if system.data is not None:
        system.data.to_csv(filename)
        print(f"Dataset with technical indicators saved to {filename}")
        print(f"Dataset contains {len(system.data)} rows and {len(system.data.columns)} columns")
    else:
        print("No dataset available to save")

def main():
    print("Barnes & Noble Education (BNED) - Multi-Level Automated Trading System")
    # comparison across all risk levels
    results_df = compare_risk_levels("BNED")
    save_results(results_df)

    # summary comparison plot
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))

    # returns comparison
    axes[0, 0].bar(results_df['risk_level'], results_df['total_return'])
    axes[0, 0].set_title('Total Return by Risk Level')
    axes[0, 0].set_ylabel('Return (%)')
    axes[0, 0].tick_params(axis='x', rotation=45)

    # win rate comparison
    axes[0, 1].bar(results_df['risk_level'], results_df['win_rate'])
    axes[0, 1].set_title('Win Rate by Risk Level')
    axes[0, 1].set_ylabel('Win Rate (%)')
    axes[0, 1].tick_params(axis='x', rotation=45)

    # Sharpe ratio comparison
    axes[1, 0].bar(results_df['risk_level'], results_df['sharpe_ratio'])
    axes[1, 0].set_title('Sharpe Ratio by Risk Level')
    axes[1, 0].set_ylabel('Sharpe Ratio')
    axes[1, 0].tick_params(axis='x', rotation=45)

    # trades comparison
    axes[1, 1].bar(results_df['risk_level'], results_df['total_trades'])
    axes[1, 1].set_title('Total Trades by Risk Level')
    axes[1, 1].set_ylabel('Number of Trades')
    axes[1, 1].tick_params(axis='x', rotation=45)

    plt.tight_layout()
    plt.savefig('risk_level_comparison.png', dpi=300, bbox_inches='tight')
    plt.show()

if __name__ == "__main__":
    main()